# Software Architecture Document for MEMOURI

- - -

## 1. Introduction

### 1.1 Purpose

본 프로젝트의 목적은 LG 스마트 TV의 운영체제인 webOS에서 구동 가능한 미디어 웹 애플리케이션을 개발하는 것입니다.<br/>
이 애플리케이션은 기본적으로 소셜 미디어 플랫폼의 구조를 갖고 있으며, '그룹'이라는 단위를 통해 같은 관심사나 목적을 가진 사용자들 간의 상호작용을 촉진합니다.<br/>
예를 들어, 같은 수업을 듣는 학생들, 음악을 좋아하는 사람들, 골프 애호가 등이 각자의 목적에 따라 그룹을 형성하고, 과제 발표 영상, 노래를 부르는 영상, 퍼팅 폼 등을 공유하면서 상호작용할 수 있습니다.<br/>
기존의 미디어 컨텐츠 기반의 소셜 미디어 서비스와 달리, 본 서비스는 사용자가 자신에게 맞는 컨텐츠를 직접 선택하고 개인화된 경험을 키워 나가는 데 중점을 두어, 보다 사용자 중심적인 경험을 제공합니다.

### 1.2 Primary Functionalities

1. **그룹 기반의 상호작용**: 사용자들은 그룹 단위로 나뉘어져 동영상을 게시하고, 이를 통해 기본적인 상호작용(영상 게시, 좋아요 표시)을 할 수 있습니다.
2. **QR code를 사용한 로그인**: 스마트 TV에서 구동되는 애플리케이션의 특성상 TV 패널 또는 리모콘으로 직접 ID와 비밀번호를 입력하는 것은 사용자에게 번거로운 경험이 될 수 있습니다. 이를 해소하기 위해 기본적인 로그인 기능 외 QR code 로그인 기능을 추가적으로 제공하여 사용자의 편의를 제고합니다.
3. **개인화된 사용자 경험**: 사용자의 영상의 이어보기 시점, 핀(고정) 설정 등이 개인화되어 다양한 경험을 할 수 있습니다. 이는 각 사용자의 행동 패턴을 반영합니다.
4. **동적 썸네일 이미지**: 동영상의 썸네일 이미지는 5초 단위로 추출되고, 각 사용자가 영상을 어디까지 시청했는지를 반영하여 시청 시점에 따라 가변적으로 제공됩니다.
5. **Adaptive Streaming**: HLS 기술을 활용하여 네트워크 상황 변화에도 불구하고 사용자가 영상 컨텐츠를 실시간으로 원활히 시청할 수 있도록 지원합니다.

- - -

## 2. Architectural Drivers

### 2.1 Functional Requirements

1. **그룹 기반 상호작용**: 사용자들은 그룹 단위로 나뉘어 동영상을 게시하고, 이를 통해 기본적인 상호작용(영상 게시, 좋아요 표시)을 할 수 있습니다.
   - 사용자는 그룹을 생성할 수 있어야 합니다.
   - 사용자는 그룹에 가입할 수 있어야 합니다.
   - 사용자는 그룹을 탈퇴할 수 있어야 합니다.
   - 사용자는 그룹을 삭제할 수 있어야 합니다.
   - 사용자는 그룹에 동영상을 게시할 수 있어야 합니다.
   - 사용자는 동영상에 좋아요를 표시할 수 있어야 합니다.

2. **QR Code를 사용한 로그인**: 사용자가 스마트 TV에서 QR 코드를 스캔하여 간편하게 로그인할 수 있는 기능을 제공합니다. 이는 TV 패널 또는 리모콘을 통한 ID와 비밀번호 입력의 번거로움을 줄여줍니다.
   - 사용자는 스마트 TV 대신 QR code를 스캔한 기기로 로그인할 수 있어야 합니다.

3. **개인화된 사용자 경험**: 사용자는 영상의 이어보기 시점, 핀(고정) 설정 등을 개인화하여 다양한 경험을 할 수 있습니다. 이는 각 사용자의 행동 패턴을 반영합니다.
   - 사용자가 동영상 시청 중 정지하거나 종료하면 해당 시점은 기록되어야 합니다.
   - 사용자가 동영상을 다시 재생할 시 이전에 보고 있었던 시점부터 재생되어야 합니다.
   - 사용자가 그룹 내 특정 동영상을 고정할 경우 해당 동영상은 목록에서 가장 앞에 위치해야 합니다.
   - 사용자마다 고정된 동영상 목록, 동영상 재생 시점이 달리 기록될 수 있어야 합니다.

4. **동적 썸네일 이미지**: 동영상의 썸네일 이미지는 5초 단위로 추출되며, 각 사용자가 영상을 어디까지 시청했는지에 따라 시청 시점에 따라 가변적으로 제공됩니다.
   - 사용자가 동영상 시청 중 정지하거나 종료하면 5초 단위로 동영상 목록에서 썸네일 이미지가 변경되어야 합니다.

5. **Adaptive Streaming**: HLS 기술을 활용하여 네트워크 상황 변화에도 불구하고 사용자가 영상 컨텐츠를 실시간으로 원활히 시청할 수 있도록 지원합니다.
   - 사용자가 업로드한 동영상은 H.264로 인코딩되고 144p, 240p, 360p, 480p, 720p, 1080p 해상도별로 분리되어야 합니다.
   - 해상도별로 분리된 동영상은 또 다시 세그먼트라는 단위로 쪼개져야 합니다.
   - 세그먼트들을 합쳐 플레이리스트를 만들고, 최종적으로 플레이리스트들의 플레이리스트인 마스터 플레이리스트가 생성되어야 합니다.


### 2.2 Non-Functional Requirements

1. **제품 요구 사항**
   - **사용성**: 스마트 TV에서 리모콘 또는 터치 패널을 사용하여 그룹 선택 및 동영상 재생을 간편하게 할 수 있도록 해야 합니다.
   - **효율성**: 서버는 다수의 사용자가 동시에 동영상을 업로드할 경우에도 안정적으로 작동하며, 최대 16GB의 메모리만 사용하도록 최적화되고 제한되어야 합니다.
   - **신뢰성**: 서버는 동시에 발생하는 다수의 동영상 업로드 요청을 100% 처리할 수 있어야 합니다.

2. **조직 요구 사항**
   - **구현**: 동영상을 재생하는 스마트 TV 웹 앱(Enact)과 동영상을 업로드하는 웹 서비스(React)를 분리하여 구현합니다. 백엔드는 Node.js와 MongoDB를 사용합니다. 이렇게 모든 영역에서 JavaScript 언어를 사용하여 코드의 이해도와 가독성을 높입니다.
   
3. **외부 요구 사항**
   - **안전성**: 사용자가 저장한 동영상의 원본 파일 및 인코딩된 파일의 경로는 외부에 노출되지 않도록 보호돼야 합니다.

- - -

## 3. Architecture Overview

### 3.1 Front-end Architecture

1. **프론트엔드 프레임워크 및 기본구조**

   1. 기술 스택
   - 사용된 프레임워크: `enact framework`, `react framework`
   - 사용된 라이브러리: `@enact/core`, `@enact/sandstone`, `axios`, `scss`, `data-fns`

   2. 프로젝트 구조
   - React 앱과 Enact Web App은 서로 다른 로컬환경에서 실행됩니다. React 앱은 어느 웹 클라이언트에서나 동작할 수 있으며, Enact Web App은 WebOS환경의 smart TV하에서 구동가능합니다. 이 두개의 클라이언트 프로그램은 동일한 서버와 API를 이용하여 데이터를 교환하고 서로 다른 클라이언트에 적용하여 사용할 수 있습니다. 




2. **UI/UX 디자인 원칙**

   1. 사용자 경험 (UX)
   - **React App**
   사용자 편의성을 고려한 디자인 및 반응형 레이아웃 구현.
   접근성 고려 사항을 적용하여 모든 사용자에게 편한 경험 제공.
   - **Enact Web App**
   모바일 및 TV 환경에서의 최적화된 사용자 경험 제공.
   색상, 테마 등 Enact 특화의 UI 디자인 원칙을 적용.

   2. 사용자 인터페이스 (UI)
   - **React App**
   React의 컴포넌트를 활용한 일관된 UI 디자인을 적용합니다.
   SCSS를 사용하여 스타일 관리 및 재사용성을 항상시킵니다.
   - **Enact Web App**
   Enact의 sandstone UI 컴포넌트 및 테마를 활용하여 일관성 있는 UI 제공합니다.
   디바이스에 맞게 UI 컴포넌트를 최적화하여 구현할 수 있도록 합니다.


3. **컴포넌트 구조**

   1. React 컴포넌트
      
      - `Login` 컴포넌트

      **역할 및 책임**: 사용자의 인증을 처리하는 로그인 컴포넌트로, 사용자가 아이디와 비밀번호를 입력하여 로그인할 수 있도록 합니다.
      
      **재사용 가능한 컴포넌트**: Login 컴포넌트는 다양한 부분에서 사용자 인증이 필요한 경우에 재사용될 수 있습니다.

      - `Editor` 컴포넌트
      
      **역할 및 책임**: 동영상 업로드를 담당하는 비디오 업로더 컴포넌트로, 사용자가 동영상 파일을 선택하고 업로드할 수 있는 환경을 제공합니다.
      
      **재사용 가능한 컴포넌트**: Editor 컴포넌트는 여러 부분에서 동영상 업로드 기능이 필요한 경우에 재사용될 수 있습니다.

      - `Signin` 컴포넌트
      
      **역할 및 책임**: 회원가입을 처리하는 컴포넌트로, 사용자가 필요한 정보를 입력하여 회원으로 가입할 수 있도록 합니다.
      
      **재사용 가능한 컴포넌트**: Signin 컴포넌트는 다양한 부분에서 회원가입 기능이 필요한 경우에 재사용될 수 있습니다.

      - `UploadField` 컴포넌트
      
      **역할 및 책임**: 사용자가 서버에 업로드한 동영상을 보여주는 컴포넌트로, 업로드된 동영상의 정보와 미리보기를 표시합니다.
      
      **재사용 가능한 컴포넌트**: UploadField 컴포넌트는 다양한 부분에서 사용자의 업로드 상태 및 동영상 정보를 표시하는 데 재사용될 수 있습니다.
   

   2. Enact 컴포넌트
	   
      - `Login` 컴포넌트

      **역할 및 책임**: 사용자의 인증을 처리하는 로그인 컴포넌트로, 사용자가 아이디와 비밀번호를 입력하여 로그인할 수 있도록 합니다.
      
      **재사용 가능한 컴포넌트**: Login 컴포넌트는 다양한 부분에서 사용자 인증이 필요한 경우에 재사용될 수 있습니다.

      - `QrCode` 컴포넌트
      
      **역할 및 책임**: 사용자의 인증을 큐알코드를 이용해 처리하는 컴포넌트로, 사용자가 큐알코드를 스캔해 로그인할 수 있도록 합니다.
      
      **재사용 가능한 컴포넌트**: QrCode 컴포넌트는 여러 부분에서 사용자 인증 기능이 필요한 경우에 재사용될 수 있습니다.

      - `Header` 컴포넌트
      
      **역할 및 책임**: 그룹 목록을 나타내는 컴포넌트로, 사용자가 가입한 그룹 목록을 확인할 수 있습니다.
      
      **재사용 가능한 컴포넌트**: Header 컴포넌트는 다양한 부분에서 그룹 목록을 띄우는 기능이 필요한 경우에 재사용될 수 있습니다.

      - `GroupVideo` 컴포넌트
      
      **역할 및 책임**: 사용자가 가입한 그룹별 동영상을 보여주는 컴포넌트로, 업로드된 동영상의 썸네일과 제목을 표시합니다.
      
      **재사용 가능한 컴포넌트**: GroupVideo 컴포넌트는 다양한 부분에서 사용자가 가입한 그룹의 동영상 정보를 표시하는 데 재사용될 수 있습니다.

      - `SpecificVideo` 컴포넌트
      
      **역할 및 책임**: 특정 동영상을 보여주는 컴포넌트로, 사용자가 선택한 동영상과 제목, 내용을 보여주고 좋아요 기능과 영상 핀 고정 기능을 사용할 수 있습니다.
      
      **재사용 가능한 컴포넌트**: SpecificVideo 컴포넌트는 다양한 부분에서 동영상 재생이 필요한 경우에 재사용될 수 있습니다.

      - `HLSVideo` 컴포넌트
      
      **역할 및 책임**: 동영상 재생 시점을 불러오는 컴포넌트로, 동영상의 자동 이어보기 기능을 구현합니다.
      
      **재사용 가능한 컴포넌트**: HLSVideo 컴포넌트는 다양한 부분에서 동영상의 재생 시점을 불러오는 데 재사용될 수 있습니다.
   
      
   4. 컴포넌트 통신
      - 부모-자식 간의 데이터 전달은 props를 통해 이루어지며, 이벤트 및 상태 관리는 각 컴포넌트 내에서 로컬 상태와 이벤트 핸들러를 활용하여 수행됩니다.
      
   3. 컴포넌트 통신
      - 부모-자식 간의 데이터 전달은 props를 통해 이루어지며, 이벤트 및 상태 관리는 각 컴포넌트 내에서 로컬 상태와 이벤트 핸들러를 활용하여 수행됩니다.



5. **클라이언트-서버간의 통신**

   4.1 API 통신
   - React 애플리케이션과 Enact 웹 앱은 공통된 서버를 활용하여 데이터를 주고받습니다. 통합된 백엔드 서비스를 통해 RESTful API를 호출하며, 이를 통해 서로 다른 플랫폼에서도 데이터의 일관성을 유지합니다.
   
   4.2 보안 및 권한
   - **인증 프로세스**: 사용자 로그인 시에 서버에서 발급한 토큰을 쿠키에 저장하고, 이를 활용하여 사용자를 식별합니다. 토큰은 유효기간이 설정되어 만료 시 자동 갱신되거나 재인증을 요청합니다.
   - **권한 관리**: 각 사용자는 특정 권한을 부여받습니다. 서버에서는 권한을 확인하여 허용된 작업만 수행되도록 합니다. 쿠키에는 사용자의 권한 정보도 함께 저장되어 클라이언트 측에서도 권한을 체크할 수 있습니다.


### 3.2 Back-end Architecture

1. **MongoDB Schema**

   데이터베이스에는 User(사용자), Picture(프로필 이미지), Group(그룹), GroupUser(사용자의 그룹 가입 정보), Video(동영상), UserVideo(동영상에 대한 사용자의 개인화된 정보) 총 6개의 스키마가 존재합니다.
이 스키마들은 사용자, 그룹, 동영상 세 가지 핵심 요소 및 그들 간의 상호작용을 효율적으로 나타낼 수 있습니다.


2. **서버 구조 및 사용 기술**
   - **Node.js와 Express 프레임워크**: 백엔드 API 서버는 Node.js와 Express 프레임워크를 기반으로 구축되었습니다.
   - **외부 패키지 및 미들웨어**: cookie-parser, body-parser, cors, dotenv, multer 등의 패키지를 사용하여 서버 기능을 강화하고, 라우터 코드의 가독성을 높이기 위해 컨트롤러(미들웨어)로 분리하였습니다.
   - **라이브러리**: fluent-ffmpeg과 hls-parser 라이브러리를 사용하여 동영상 처리 기능을 강화하였습니다.

3. **보안 및 인증**
   - **JWT 토큰 기반 인증**: 로그인 시 JWT 토큰을 발급하고, 이를 쿠키 방식으로 교환하여 사용자 인증을 관리합니다.
   - **미들웨어를 통한 토큰 검증**: 로그인 후 사용 가능한 모든 API에 대해 토큰을 검증하는 미들웨어를 구현하였습니다.
   - **보안 관련 추가 조치**: 쿠키의 httpOnly 속성 설정, 파일 경로의 은폐 등을 통해 시스템 보안을 강화하였습니다.

4. **성능 및 확장성**
   - **데이터베이스 접근 최적화**: 토큰 기반 인증 캐싱이라는 방법론을 구상하여 컨트롤러에서의 데이터베이스 요청 최적화를 통해 효율적인 데이터 관리를 달성하였습니다. 토큰 기반 인증 캐싱이란, 로그인 시 이미 사용자의 존재성이 입증되었으므로 로그인을 통해 생성된 JWT 토큰을 받는 것만으로 사용자의 정보가 데이터베이스에 존재한다고 결론짓는 것입니다.
   - **파일 시스템 관리**: 파일 경로를 데이터베이스에 저장하지 않고 사용자 및 동영상의 id 기반으로 관리하여 데이터베이스와 파일 시스템의 일관성을 유지를 간편하게 하였습니다.

5. **에러 처리 및 로깅**
   - 에러 코드 관리: 명확하고 일관적인 에러 코드를 사용하여 프론트엔드-백엔드 간 소통이 원활했고 효율적인 디버깅이 가능했습니다.
   - 오류 처리 로직: 데이터 일관성을 유지하기 위해 존재성 검증을 중심으로 한 오류 처리 로직을 구현하였습니다.

모든 API에서 일관되게 사용한 상태 코드의 표는 다음과 같습니다.

| Code | Meaning |
| :--: | :-- |
| 200 | 성공 |
| 400 | 토큰 검증 오류 |
| 401 | 데이터베이스에 등록되지 않은 사용자 id |
| 402 | 올바르지 않은 사용자 password |
| 403 | 사용자가 그룹의 master로 존재함 |
| 404 | 잘못된 경로 요청 |
| 405 | 사용자가 그룹에 가입되어 있지 않음 |
| 406 | - |
| 407 | 중복된 사용자 id 존재 |
| 408 | 스트림 데이터 전송 중 오류 발생 |
| 409 | 데이터베이스에 동영상 존재하지 않음 |
| 410 | 파일 시스템에 파일이 존재하지 않음 |
| 411 | 등록되지 않은 그룹 id |
| 412 | 중복된 그룹 id 존재 |
| 413 | 그룹 비밀번호 불일치 |
| 414 | 사용자가 이미 그룹에 가입됨 |
| 415 | 파일 시스템에 프로필 이미지 존재하지 않음 |
| 499 | 접근 권한 위반 |
| 500 | 서버 에러 발생 |

- - -

## 4. Data Design

<p align="center">
<img width="800" alt="memouri_erd" src="https://github.com/mediaWebAppTeam5/memouri_backend/assets/89457737/ee434dea-8f65-4700-8e77-ce2ecbfa41fa">
</p>

**User Schema**: 서비스 사용자
| Field | Type | Meaning |
| :--: | :--: | :-- |
| userId | String | 사용자 아이디 |
| password | String | 비밀번호 |
| name | String | 사용자 이름 |
| email | String | 사용자 이메일 |
| picture | ObjectId | 사용자 프로필 이미지(Picture의 Object ID, null이면 프로필 이미지가 없는 것) |
| createdAt | Date | 생성 일시(= 회원 가입 일시) |
| updatedAt | Date | (사용자 정보의) 수정 일시 |

**Picture Schema**: 사용자 프로필 이미지
| Field | Type | Meaning |
| :--: | :--: | :-- |
| user | ObjectId | 사용자(사용자의 Object ID) |
| ext | String | 저장된 프로필 이미지의 확장자 |

**Group Schema**: 사용자 간의 그룹
| Field | Type | Meaning |
| :--: | :--: | :-- |
| master | ObjectId | 그룹 운영자(사용자의 Object ID) |
| groupId | String | 그룹 아이디 |
| password | String | 비밀번호 |
| name | String | 그룹 이름 |
| createdAt | Date | 생성 일시(= 그룹 생성 일시) |
| updatedAt | Date | (그룹 정보의) 수정 일시 |

**GroupUser Schema**: 사용자의 그룹 가입 정보
| Field | Type | Meaning |
| :--: | :--: | :-- |
| group | ObjectId | 그룹(그룹의 Object ID) |
| user | ObjectId | 그룹에 속한 사용자(사용자의 Object ID) |
| createdAt | Date | 생성 일시(= 사용자의 그룹 가입 일시) |

**Video Schema**: 동영상
| Field | Type | Meaning |
| :--: | :--: | :-- |
| videoId | String | "[업로더 ID][업로드 일시]" 포맷 |
| uploader | ObjectId | 동영상 업로더(사용자의 Object ID) |
| group | ObjectId | 동영상이 속한 그룹(그룹의 Object ID) |
| title | String | 동영상 제목 |
| description | String | 동영상 설명 |
| like | Number | 동영상 좋아요 개수 |
| view | Number | 동영상 조회수 |
| lengthInSeconds | Number | 동영상 길이(초 단위) |
| createdAt | Date | 생성 일시(= 동영상 생성 일시) |
| updatedAt | Date | (동영상 정보의) 수정 일시 |

**UserVideo Schema**: 동영상의 개인화된 정보(사용자마다 다를 수 있는 정보)
| Field | Type | Meaning |
| :--: | :--: | :-- |
| user | ObjectId | 사용자(사용자의 Object ID) |
| video | ObjectId | 동영상(동영상의 Object ID) |
| pinnedAt | Date | 동영상 고정 일시(null이면 고정하지 않은 것, 기본값 null) |
| likedAt | Date | 동영상 좋아요 표시 일시(null이면 좋아요 표시를 하지 않은 것, 기본값 null) |
| markInSeconds | Number | 동영상 이어보기 시점(기본값 0) |

1. **데이터 관리 및 저장 전략**
   - **효율적인 데이터 저장**: 동영상, 썸네일 이미지, 인코딩된 동영상 등의 저장 경로는 동영상의 ID(videoId)만으로 유도될 수 있도록 일관성 있게 설계되었습니다. 따라서 필수적인 정보인 videoId만을 데이터베이스에 저장하고, 파일 경로는 저장하지 않음으로써 공간적인 효율성을 높였습니다. 
   - **MongoDB로 다대다 관계를 나타내는 스키마 설계**: NoSQL 데이터베이스인 MongoDB를 사용하여 UserVideo, GroupUser 등의 별도 스키마를 구성함으로써 사용자와 동영상, 사용자와 그룹 간의 다대다 관계를 효과적으로 표현했습니다.
   - **파일 시스템 관리**: 파일 시스템에 저장되는 해상도별 동영상 파일은 H.264, ACC 코덱으로 인코딩하여 그 용량을 최소화하였습니다.

2. **데이터 보안 전략**
   - **JWT 토큰 기반 인증**: 로그인 후 사용 가능한 모든 API에서는 JWT 토큰 검증 미들웨어를 사용하여 보안을 강화하고 있습니다. 이를 통해 인증된 사용자만이 데이터베이스에 접근하는 API들을 사용할 수 있습니다.
   - **스트리밍 데이터 보안**: 클라이언트 측에서 HLS 스트리밍을 위해 세그먼트 파일을 요청할 때, 파일 시스템을 직접 공개하지 않고 토큰 검증 후에 파일을 제공하는 방식으로 데이터 보안을 강화하였습니다.

3. **데이터 처리 및 변환**
   - **FFmpeg을 활용한 동영상 처리**: 동영상 썸네일 생성, 인코딩, HLS 스트리밍을 위한 세그먼트와 플레이리스트 생성에 FFmpeg을 사용했습니다. Node.js의 fluent-ffmpeg 라이브러리를 통해 JavaScript 문법으로 FFmpeg 기능을 구현하였습니다.

- - -

## 5. Technical Stack Structure and Visualization

### 5.1. 전체 프로젝트 구조

<img width="617" alt="아키텍처" src="https://github.com/mediaWebAppTeam5/memouri_backend/assets/89457737/32aaaf44-4a9f-4c83-bad9-9cbb06ee9e26">

### 5.2. Sequence Diagram
애플리케이션에서 중요한 기능인 Authentication과 Video 관련 시퀀스 다이어그램입니다.

#### 5.2.1. Authentication

<img width="628" alt="authentication" src="https://github.com/mediaWebAppTeam5/memouri_backend/assets/89457737/3319711f-ec35-47bc-a50c-aa2797592a29">

#### 5.2.2. Video

<img width="644" alt="video" src="https://github.com/mediaWebAppTeam5/memouri_backend/assets/89457737/dca9ad19-739b-4c76-827b-06ec46f3811d">

- - -
